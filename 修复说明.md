# 数据库连接池耗尽问题 - 修复说明

## 问题原因

你遇到的错误：
```
QueuePool limit of size 15 overflow 30 reached, connection timed out, timeout 10.00
```

**根本原因**：
1. ❌ **后台线程未释放数据库连接** - `socketio_events.py` 中的异步函数使用数据库后没有调用 `db.session.remove()`
2. ❌ **缺少全局会话清理机制** - Flask应用没有配置 `@app.teardown_appcontext` 钩子
3. ❌ **连接池配置偏小** - 在高并发访客场景下，45个连接（15基础+30溢出）不够用

## 已修复的文件

### 1. `app.py` - 添加全局会话清理
```python
@app.teardown_appcontext
def shutdown_session(exception=None):
    """请求结束后清理数据库会话"""
    db.session.remove()
```

### 2. `socketio_events.py` - 修复2个异步函数
- `async_save_visitor()` - 访客信息保存
- `push_comment_request()` - 评价请求推送

都添加了：
```python
finally:
    db.session.remove()
```

### 3. `config.py` - 优化连接池配置
- `pool_size`: 15 → **20**
- `max_overflow`: 30 → **40**
- `pool_timeout`: 10 → **30秒**
- 添加 `pool_reset_on_return: "rollback"` 自动回滚

### 4. `Tasks/db_health_check.py` - 修复健康检查
添加会话清理，避免定时任务泄漏连接

## 立即执行的修复步骤

### 方法1：使用快速修复脚本（推荐）

```bash
bash quick_fix.sh
```

这个脚本会：
1. 检查当前连接池状态
2. 清理泄漏的连接
3. 提示你重启应用

### 方法2：手动执行

```bash
# 1. 检查连接池状态
python check_db_pool.py

# 2. 清理连接
python fix_db_connections.py

# 3. 重启应用
systemctl restart kefu-flask
# 或
pkill -f "python.*app.py" && pkill -f "gunicorn"
```

## 验证修复

重启后，运行以下命令验证：

```bash
# 1. 检查连接池状态
python check_db_pool.py

# 2. 监控日志（不应再出现 QueuePool 错误）
tail -f logs/error.log | grep -i "pool\|timeout"

# 3. 测试访客连接
# 打开浏览器访问你的客服系统，模拟多个访客同时连接
```

## 预期结果

✅ 不再出现 `QueuePool limit` 错误
✅ 连接池利用率保持在 70% 以下
✅ 访客连接速度正常
✅ Redis 发布正常（"Cannot publish to redis" 错误消失）

## 监控建议

### 1. 定期检查连接池（可选）

添加到 crontab：
```bash
crontab -e

# 每5分钟检查一次
*/5 * * * * cd /www/wwwroot/kefu-flask && python check_db_pool.py >> logs/pool_check.log 2>&1
```

### 2. 监控关键指标

- 连接池利用率（应 < 80%）
- 数据库连接数（MySQL: `SHOW STATUS LIKE 'Threads_connected'`）
- 应用响应时间

## 如果问题仍然存在

### 1. 检查MySQL连接数限制

```sql
SHOW VARIABLES LIKE 'max_connections';
```

如果小于 200，建议增加：
```bash
# 编辑 /etc/my.cnf
[mysqld]
max_connections = 500

# 重启MySQL
systemctl restart mysql
```

### 2. 检查是否有慢查询

```sql
SELECT * FROM information_schema.processlist 
WHERE command != 'Sleep' 
ORDER BY time DESC 
LIMIT 10;
```

### 3. 查看详细文档

```bash
cat DATABASE_CONNECTION_FIX.md
```

## 紧急恢复（如果应用完全卡死）

```bash
# 1. 强制停止所有进程
pkill -9 -f "python.*app.py"
pkill -9 -f "gunicorn"

# 2. 清理连接
python fix_db_connections.py

# 3. 重启MySQL（会断开所有连接）
systemctl restart mysql

# 4. 重新启动应用
cd /www/wwwroot/kefu-flask
python app.py
```

## 文件清单

修复相关的新文件：
- ✅ `check_db_pool.py` - 连接池状态检查工具
- ✅ `fix_db_connections.py` - 连接清理工具
- ✅ `quick_fix.sh` - 快速修复脚本
- ✅ `DATABASE_CONNECTION_FIX.md` - 详细修复文档
- ✅ `修复说明.md` - 本文件

## 技术细节

### 为什么需要 `db.session.remove()`？

Flask-SQLAlchemy 使用 **scoped_session**，它为每个线程维护独立的会话。在普通的 Flask 请求中，会话会在请求结束时自动清理。但在以下场景中需要手动清理：

1. **后台线程** - 不属于 Flask 请求上下文
2. **SocketIO 事件** - 长连接，不会自动清理
3. **定时任务** - 独立的执行上下文

不调用 `remove()` 会导致：
- 数据库连接一直被占用
- 连接池逐渐耗尽
- 新请求无法获取连接，超时报错

### 连接池配置说明

```python
pool_size = 20              # 基础连接数（常驻）
max_overflow = 40           # 额外溢出连接（临时）
总容量 = 20 + 40 = 60      # 最多60个并发连接

pool_timeout = 30           # 等待连接的最大时间
pool_recycle = 300          # 5分钟回收连接（避免MySQL超时）
pool_pre_ping = True        # 使用前测试连接是否有效
```

## 总结

这次修复解决了3个关键问题：
1. ✅ 添加全局会话清理机制
2. ✅ 修复所有后台线程的连接泄漏
3. ✅ 优化连接池配置，提高并发能力

**现在请重启应用，问题应该得到解决！**
